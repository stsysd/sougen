package model

import (
	"testing"
	"time"
)

func TestNewRecord(t *testing.T) {
	// テストデータ
	timestamp := time.Date(2025, 5, 21, 14, 30, 0, 0, time.Local)
	projectID := NewHexID(123)
	value := 1

	// レコードを生成
	tags := []string{"test", "example"}
	record, err := NewRecord(timestamp, projectID, value, tags)
	if err != nil {
		t.Fatalf("Failed to create record: %v", err)
	}

	// IDが無効であることを確認（DBで自動生成される）
	if record.ID.IsValid() {
		t.Errorf("Expected ID to be invalid (auto-generated by DB), but it was valid")
	}

	// 各フィールドが正しく設定されていることを確認
	if !record.Timestamp.Equal(timestamp) {
		t.Errorf("Expected Timestamp to be %v, got %v", timestamp, record.Timestamp)
	}

	if !record.ProjectID.Equals(projectID) {
		t.Errorf("Expected ProjectID to be %d, got %d", projectID.ToInt64(), record.ProjectID.ToInt64())
	}

	if record.Value != value {
		t.Errorf("Expected Value to be %d, got %d", value, record.Value)
	}

	// Tagsフィールドが正しく設定されていることを確認
	if len(record.Tags) != 2 || record.Tags[0] != "test" || record.Tags[1] != "example" {
		t.Errorf("Expected Tags to be %v, got %v", tags, record.Tags)
	}
}

func TestValidate(t *testing.T) {
	// 有効なレコード
	if _, err := LoadRecord(
		NewHexID(1),
		time.Date(2025, 5, 21, 14, 30, 0, 0, time.Local),
		NewHexID(123),
		1,
		[]string{"valid"},
	); err != nil {
		t.Fatalf("Failed to create valid record: %v", err)
	}

	// 無効なレコード（IDが無効）
	if _, err := LoadRecord(
		HexID{},
		time.Date(2025, 5, 21, 14, 30, 0, 0, time.Local),
		NewHexID(123),
		1,
		[]string{},
	); err == nil {
		t.Error("Expected error for invalid ID, got nil")
	}

	// 無効なレコード（タグにスペースが含まれる）
	if _, err := LoadRecord(
		NewHexID(1),
		time.Date(2025, 5, 21, 14, 30, 0, 0, time.Local),
		NewHexID(123),
		1,
		[]string{"invalid tag"},
	); err == nil {
		t.Error("Expected error for tag containing space, got nil")
	}

	// 無効なレコード（空のタグ）
	if _, err := LoadRecord(
		NewHexID(1),
		time.Date(2025, 5, 21, 14, 30, 0, 0, time.Local),
		NewHexID(123),
		1,
		[]string{""},
	); err == nil {
		t.Error("Expected error for empty tag, got nil")
	}

	// 有効なレコード（タグなし）
	if _, err := LoadRecord(
		NewHexID(1),
		time.Date(2025, 5, 21, 14, 30, 0, 0, time.Local),
		NewHexID(123),
		1,
		[]string{},
	); err != nil {
		t.Errorf("Expected no error for record without tags, got: %v", err)
	}
}

func TestNewDateRange(t *testing.T) {
	tests := []struct {
		name    string
		fromStr string
		toStr   string
		wantErr bool
		checkFn func(*DateRange) bool
	}{
		{
			name:    "full datetime format",
			fromStr: "2025-01-01T10:30:45Z",
			toStr:   "2025-01-02T15:45:30Z",
			wantErr: false,
			checkFn: func(dr *DateRange) bool {
				// from should be normalized to 00:00:00
				expectedFrom := time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)
				// to should be normalized to 23:59:59.999999999
				expectedTo := time.Date(2025, 1, 2, 23, 59, 59, 999999999, time.UTC)
				return dr.From().Equal(expectedFrom) && dr.To().Equal(expectedTo)
			},
		},
		{
			name:    "date only format",
			fromStr: "2025-01-01",
			toStr:   "2025-01-02",
			wantErr: false,
			checkFn: func(dr *DateRange) bool {
				// from should be normalized to 00:00:00
				expectedFrom := time.Date(2025, 1, 1, 0, 0, 0, 0, time.UTC)
				// to should be normalized to 23:59:59.999999999
				expectedTo := time.Date(2025, 1, 2, 23, 59, 59, 999999999, time.UTC)
				return dr.From().Equal(expectedFrom) && dr.To().Equal(expectedTo)
			},
		},
		{
			name:    "mixed format",
			fromStr: "2025-01-01",
			toStr:   "2025-01-02T12:30:45Z",
			wantErr: false,
			checkFn: func(dr *DateRange) bool {
				// Both should be normalized properly
				return dr.From().Hour() == 0 && dr.To().Hour() == 23
			},
		},
		{
			name:    "invalid format",
			fromStr: "invalid-date",
			toStr:   "2025-01-02",
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			dr, err := NewDateRange(tt.fromStr, tt.toStr)
			if (err != nil) != tt.wantErr {
				t.Errorf("NewDateRange() error = %v, wantErr %v", err, tt.wantErr)
				return
			}
			if !tt.wantErr && tt.checkFn != nil && !tt.checkFn(dr) {
				t.Errorf("NewDateRange() validation failed for %s", tt.name)
			}
		})
	}
}
